---
layout: post
title: 检查点
date: 2018-03-05
tag: sink
---

### 以下内容属于转载
```
1、SCN的概念
SCN可以理解为oracle的内部时钟，是oracle内部自己维护的一个只增不减的序列，oracle的每个事物都是靠SCN来标示发生的先后顺序。
因为若是以系统时间为依照，若发生系统时间调整，则oracle的内部事物顺序就乱套了。
获取系统当前SCN号有两种方式
    select a.CURRENT_SCN from v$database a;
    select dbms_flashback.get_system_change_number from dual;


2、checkpoint的概念
checkpoint是为了减小oracle实例恢复的时间的。oracle使用先写redo,后写数据文件的方式来提高系统效率，因为redo是顺序写，而数据文件是随机写。这种情况下就有可能造成未写入数据文件的数据块过多，导致异常宕机后恢复一致性需要的时间太长。
checkpoint发生后，首先获取发生检查点时刻的SCN，然后通知DBWn进程开始把此时刻SCN的数据块都写入到数据文件，最后更新数据文件头和控制文件中的checkpoint信息。


checkpoint的作用
保证数据库的一致性，触发DBWn将脏数据块写入磁盘。
缩短实例恢复的时间。


checkpoint的分类
完全检查点
增量检查点


完全检查点
工作过程
一个checkpoint操作可以分成三个不同的阶段：
1、CKPT进程开始一个checkpoint事件，并记录下checkpoint RBA，这个通常是当前的RBA。
2、CKPT进程通知DBWn进程将所有checkpoint RBA之前的buffer cache里面的脏块写入磁盘。
3、确定脏块都被写入磁盘以后进入到第阶段，checkpoint进程将checkpoint信息（SCN）写入/更新数据文件和控制文件中。
更新SCN的操作由CKPT进程完成，在Oracle 8.0之后CKPT进程默认是被启用的，如果CKPT进程没有启用的话那相应的操作将由LGWR进程完成。


触发条件
1、日志切换，alter system switch logfile;
2、手动checkpoint，alter system checkpoint;
3、关闭库，shutdown；




增量检查点
工作过程
增量检查点跟完全检查点不同，它不触发DBWn的写操作，而是使用一个BCQ（buffer checkpoint queue），数据库产生的脏块按照其首次被修改的scn号排序进入序列，DBWn写的时候按照序列的顺序写入磁盘。增量检查点持续活动，按照一定频率检查DBWn当前完成的写入位置（rba（redo byte address）），并将该位置更新到控制文件中。
这样数据库实例恢复的时候就只需要从当前rba进行恢复，而不需要从上次完全检查点的位置开始恢复了。


触发条件
1、参数
log_checkpoint_interval 两次checkpoint间的重做日志块数量。
fast_start_io_target  两次checkpoint间的脏数据块数量。
fast_start_mttr_target 快速恢复的时间，最大值为3600即一小时。设定该值后oracle会将其内在的解释为log_checkpoint_interval和fast_start_io_target两个参数。
如果fast_start_io_target or log_checkpoint_interval被指定，他们会自动覆盖由fast_start_mttr_target参数计算出来的值。
10g以后，在dba不设定参数值的情况下，系统可以自动计算增量检查点的触发间隔。


  此外，检查点还有
数据文件/表空间检查点，如数据文件热备；更改数据文件或表空间状态，alter tablespace/datafile read only;情况下。
对象检查点，发生对象drop、truncate操作时。
等。


 因此，oracle内部维护了一个ACQ（active checkpoint queue），各个类型检查点优先级不同，有些检查点不会立即触发DBWn写。




oracle分别在控制文件和数据文件头记录了多个checkpoint号。


------控制文件中的系统检查点号
select c.NAME,c.CHECKPOINT_CHANGE# from v$database c


------控制文件中的文件检查点号和结束检查点号
select d.NAME,d.CHECKPOINT_CHANGE#,d.LAST_CHANGE# from v$datafile d 
对于处于online状态的datafile，其last_change#为无穷大。当将datafile至于offline状态，或正常关闭数据库时，oracle会将last_change#更改为当时的checkpoint#，及与控制文件中该文件的checkpoint_change#相同，若启动时发现文件的last_change#为无穷大，则判定该文件未正常关闭。


------文件头检查点号
select b.NAME,b.CHECKPOINT_CHANGE# from v$datafile_header b


可以通过dump控制文件的方式查看具体保存的内容。
dump controlfile的语句
 ALTER SESSION SET events 'immediate trace name controlf level 8';


checkpoint和SCN的关系
scn就相当于时钟，checkpoint就是一个事件，是数据库的一个为了提高效率和减小系统故障恢复事件引入的一个事件。checkpoint根据一定策略发生一次，每次发生都用当时的scn来记录该事件的发生。
所以在通过各个视图查出来的scn都没有直接叫scn什么的，而是叫checkpoint号，而这个checkpoint号就是发生checkpoint时刻的scn。


完全检查点与增量检查点的区别
发生完全检查点的时候会首先触发dbwn进程对当前scn之前的数据进行写入，之后更新控制文件中的system checkpoint#、datafile checkpoint#和数据文件头中的start_checkpoint#以及rba。
增量检查点值更新控制文件中的rba。比较怀疑的一点：增量检查点也会检查BCQ的长度，若BCQ长度过长，也会触发dbwn进行写操作。
从完全检查点的触发条件看，出了手动的checkpoint外，只有switch log会造成完全检查点的发生。也就是基本只有switch log的时候，才会更新控制文件中和数据文件头中的各种checkpoint#，因此检查数据库可以发现这几个checkpoint#和v$log中日志的first_change#一致。




alter system set log_checkpoints_to_alert = true scope=both;
可以将检查点信息写入alert日志，但对于增量检查点只会记录设置log_checkpoint_timeout参数的情况。


触发DBWR进程的条件有： 
1.  DBWR超时，大约3秒 
2. 系统中没有多余的空缓冲区来存放数据 
3.  CKPT 进程触发DBWR


1.从理解LOGW什么时候将redo log buffer中把redo写入redo log file理解commit;
当redo log buffer 三分之一满的时候写
当commit的时候写
当发生日志切换的时候写
当产生的redo满1M的时候写
当DBWN要写的时候，先写redo
每3秒写
```

转自:http://blog.csdn.net/jx_jy/article/details/56009810

转载请注明 : [sinkshark的博客](http://sinkshark.com/)